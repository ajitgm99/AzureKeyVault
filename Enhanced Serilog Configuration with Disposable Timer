Here's the complete implementation with all files for both projects, including the disposable timer functionality:

Complete Solution Structure
Solution/
├── Common.Logging/
│   ├── Enrichers/
│   │   ├── TimeTakenEnricher.cs
│   │   ├── RequestPathEnricher.cs
│   ├── Extensions/
│   │   ├── SerilogExtensions.cs
│   ├── Utilities/
│   │   ├── DisposableTimer.cs
│   ├── SerilogConfig.cs
│   ├── Common.Logging.csproj
├── WebApi/
│   ├── Controllers/
│   │   ├── TestController.cs
│   ├── Program.cs
│   ├── WebApi.csproj
1. Common.Logging (Class Library)
Common.Logging.csproj
xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Logging" Version="8.0.0" />
    <PackageReference Include="Serilog" Version="3.1.1" />
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.1" />
    <PackageReference Include="Serilog.Sinks.Console" Version="4.2.0" />
  </ItemGroup>
</Project>
Enrichers/TimeTakenEnricher.cs
csharp
using Serilog.Core;
using Serilog.Events;
using System.Diagnostics;

namespace Common.Logging.Enrichers;

public class TimeTakenEnricher : ILogEventEnricher
{
    private readonly Stopwatch _stopwatch;

    public TimeTakenEnricher()
    {
        _stopwatch = Stopwatch.StartNew();
    }

    public void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory)
    {
        var elapsedMs = _stopwatch.ElapsedMilliseconds;
        var property = propertyFactory.CreateProperty("TimeTakenMs", elapsedMs);
        logEvent.AddPropertyIfAbsent(property);
    }
}
Enrichers/RequestPathEnricher.cs
csharp
using Microsoft.AspNetCore.Http;
using Serilog.Core;
using Serilog.Events;
using System.Security.Claims;

namespace Common.Logging.Enrichers;

public class RequestPathEnricher : ILogEventEnricher
{
    private readonly IHttpContextAccessor _httpContextAccessor;

    public RequestPathEnricher(IHttpContextAccessor httpContextAccessor)
    {
        _httpContextAccessor = httpContextAccessor;
    }

    public void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory)
    {
        var httpContext = _httpContextAccessor.HttpContext;
        if (httpContext == null) return;

        var requestPath = httpContext.Request.Path;
        logEvent.AddPropertyIfAbsent(propertyFactory.CreateProperty("RequestPath", requestPath));

        var endpoint = httpContext.GetEndpoint();
        if (endpoint != null)
        {
            var actionDescriptor = endpoint.Metadata.GetMetadata<Microsoft.AspNetCore.Mvc.Controllers.ControllerActionDescriptor>();
            if (actionDescriptor != null)
            {
                logEvent.AddPropertyIfAbsent(propertyFactory.CreateProperty("ActionPath", 
                    $"{actionDescriptor.ControllerName}.{actionDescriptor.ActionName}"));
            }
        }
    }
}
Extensions/SerilogExtensions.cs
csharp
using Common.Logging.Enrichers;
using Serilog;

namespace Common.Logging.Extensions;

public static class SerilogExtensions
{
    public static LoggerConfiguration WithBasicEnrichers(this LoggerConfiguration config)
    {
        return config
            .Enrich.WithProcessId()
            .Enrich.WithMachineName()
            .Enrich.With(new TimeTakenEnricher());
    }

    public static LoggerConfiguration WithWebApiEnrichers(this LoggerConfiguration config)
    {
        return config
            .WithBasicEnrichers()
            .Enrich.FromLogContext()
            .Enrich.With<RequestPathEnricher>();
    }
}
Utilities/DisposableTimer.cs
csharp
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Microsoft.Extensions.Logging;

namespace Common.Logging.Utilities;

public class DisposableTimer : IDisposable
{
    private readonly ILogger _logger;
    private readonly Stopwatch _stopwatch;
    private readonly string _operationName;
    private readonly LogLevel _logLevel;
    private readonly IDisposable _scope;

    public DisposableTimer(
        ILogger logger,
        string operationName,
        LogLevel logLevel = LogLevel.Information,
        params (string key, object value)[] properties)
    {
        _logger = logger;
        _operationName = operationName;
        _logLevel = logLevel;
        _stopwatch = Stopwatch.StartNew();
        
        _scope = _logger.BeginScope(
            properties.ToDictionary(
                x => x.key,
                x => x.value));
    }

    public void Dispose()
    {
        _stopwatch.Stop();
        _scope?.Dispose();
        
        _logger.Log(
            _logLevel,
            "Operation {OperationName} completed in {ElapsedMs}ms", 
            _operationName, 
            _stopwatch.ElapsedMilliseconds);
    }
}

public static class DisposableTimerExtensions
{
    public static DisposableTimer TimeOperation(
        this ILogger logger,
        string operationName,
        LogLevel logLevel = LogLevel.Information,
        params (string key, object value)[] properties)
    {
        return new DisposableTimer(logger, operationName, logLevel, properties);
    }
}
SerilogConfig.cs
csharp
using Common.Logging.Extensions;
using Serilog;

namespace Common.Logging;

public static class SerilogConfig
{
    public static ILogger CreateBootstrapLogger()
    {
        return new LoggerConfiguration()
            .WithBasicEnrichers()
            .WriteTo.Console(outputTemplate: "{Timestamp:yyyy-MM-dd HH:mm:ss} [{ProcessId}] {Message}{NewLine}{Exception}")
            .CreateBootstrapLogger();
    }

    public static IHostBuilder UseSerilogConfiguration(this IHostBuilder hostBuilder)
    {
        return hostBuilder.UseSerilog((context, services, configuration) => 
        {
            configuration
                .WithWebApiEnrichers()
                .WriteTo.Console(outputTemplate: 
                    "{Timestamp:yyyy-MM-dd HH:mm:ss} " +
                    "[{ProcessId}] " +
                    "[{RequestPath}] " +
                    "[{ActionPath}] " +
                    "{Message}{NewLine}{Exception}");
        });
    }
}
2. WebApi Project
WebApi.csproj
xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.1" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Common.Logging\Common.Logging.csproj" />
  </ItemGroup>
</Project>
Program.cs
csharp
using Common.Logging;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Host.UseSerilogConfiguration();
builder.Services.AddHttpContextAccessor();

builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();

app.Run();
Controllers/TestController.cs
csharp
using Common.Logging.Utilities;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;

namespace WebApi.Controllers;

[ApiController]
[Route("[controller]")]
public class TestController : ControllerBase
{
    private readonly ILogger<TestController> _logger;

    public TestController(ILogger<TestController> logger)
    {
        _logger = logger;
    }

    [HttpGet]
    public IActionResult Get()
    {
        using (_logger.TimeOperation("TestController.Get", 
               properties: ("RequestId", Guid.NewGuid())))
        {
            // Simulate work
            Thread.Sleep(new Random().Next(50, 200));
            
            return Ok(new { Message = "Hello World", Timestamp = DateTime.UtcNow });
        }
    }

    [HttpGet("long")]
    public IActionResult GetLongRunning()
    {
        using (_logger.TimeOperation("LongRunningOperation", LogLevel.Warning,
               ("RequestId", Guid.NewGuid()),
               ("User", User.Identity?.Name ?? "anonymous")))
        {
            Thread.Sleep(1000);
            return Ok(new { Message = "Long operation completed" });
        }
    }
}
How to Use
Basic Usage:

csharp
using (_logger.TimeOperation("OperationName"))
{
    // Your code here
}
With Custom Log Level:

csharp
using (_logger.TimeOperation("CriticalOperation", LogLevel.Warning))
{
    // Critical operation
}
With Additional Properties:

csharp
using (_logger.TimeOperation("ProcessOrder", 
       properties: ("OrderId", orderId), ("Customer", customerName)))
{
    // Process order
}
Expected Output Examples
For /test endpoint:

2024-05-15 16:45:22 [54321] [/test] [Test.Get] Operation TestController.Get completed in 128ms
For /test/long endpoint:

2024-05-15 16:46:05 [54321] [/test/long] [Test.GetLongRunning] Operation LongRunningOperation completed in 1002ms
This complete implementation provides:

Structured logging with timestamps, process IDs, request paths, and action paths

Operation timing with the disposable timer pattern

Flexible logging with custom levels and additional properties

Clean separation between logging infrastructure and application code
